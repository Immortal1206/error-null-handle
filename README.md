# function programming approach for error and null handling

## API Reference

### Maybe\<A>

* just :: \<A>(value: A) => Maybe\<A>

  create a Just object

* nothing :: \<A>() => Maybe\<A>

  create a Nothing object

* fromObject :: \<A>(obj: NothingObject | JustObject\<A>) => Result\<Maybe\<A>, string>

  convert a JustObject\<A> or NothingObject to a Maybe\<A>

* fromString :: \<A>(s: string) => Result\<Maybe\<A>, string>

  convert a string generated by stringify the Maybe\<A> to a Maybe\<A>

* fromNullable :: \<A>(value: A | null | undefined) => Maybe\<A>

  Creates a Maybe instance from a nullable value.

### Maybe instance

* isJust / isNothing :: () => boolean

  indicate the instance is Just\<A> / Nothing\<A>

* unwrap :: () => A

  returns the contained Maybe value, would panic on Nothing

* unwrapOr :: (defaultValue: A) => A

  returns the contained Maybe value or a provided default value(if Nothing).

* unwrapOrElse: (f: () => A) => A

  returns the contained Maybe value or return the parameter function's return value(if Nothing).

* map :: \<B>(f: (v: A) => B) => Maybe\<B>

  convert Maybe\<A> to Maybe\<B> without unwrap the Maybe type which may caust an error

* mapOr :: \<B>(f: (v: A) => B, defaultValue: B) => B

  returns the provided default result (if Nothing), or applies the function to the contained value (if Just).

* mapOrElse :: \<B>(f: (v: A) => B, defaultValue: () => B) => B

  computes a default function result (if Nothing), or applies a different function to the contained value (if Just).

* toResult: \<B>(err: B) => Result\<A, B>

  transforms the Maybe\<A> into a Result\<A, B>, mapping Just\<A> to Ok\<A> and Nothing to Err\<B>.

* ap :: \<B>(other: Maybe\<A>) => Maybe\<B>

  apply a Maybe\<(a: A) => B> to a Maybe\<A>,

  note that the caller instance should be Maybe\<(a: A) => B>.

* bind :: \<B>(f: (a: A) => Maybe\<B>) => Maybe\<B>

  apply a function to the Maybe value without concerning about Nothing.

  return Nothing if Nothing.

*  match :: \<B>(onJust: (a: A) => B, onNothing: () => B) => B

  do something on Maybe\<A>, note that you should handle the two cases: Just\<A> and Nothing

  if return some value, the two handlers should return the same type.

  if you want to return different types, use do instead.

*  do :: \<T, U>(onJust: (a: A) => T, onNothing: () => U) => T | U

  do something on Maybe\<A>, note that you should handle the two cases: Just\<A> and Nothing

### Result\<A, B>

* ok :: \<A, B>(value: A) => Result\<A, B>

  create a Ok\<A> from value

* err :: \<A, B>(msg: B) => Result\<A, B>

  create a Err\<B> from value

* fromString :: \<A, B>(s: string) => Result\<Result\<A, B>, string>

  convert a string generated by stringify the Result\<A, B> to a Result\<A, B>

* fromObject :: \<A, B>(obj: OkObject\<A> | ErrObject\<B>) => Result\<Result\<A, B>, string>

  convert a OkObject\<A> or a ErrObject\<B> to Result\<A, B>

* fromPromise :: \<A, B = unknown>(promise: Promise\<A>) => Promise\<Result<A, B>>

  convert a Promise\<A> to a Promise\<Result\<A, B>>, handle the error by to function

### Result instance

* isOk / isErr :: () => boolean

  indicate the instance is Ok\<A> / Err\<B>

* unwrap :: () => A

  returns the contained Ok value, panic on Err.

* unwrapErr :: () => B

  returns the contained Err value, panic on Ok.

* unwrapOr :: (defaultValue: A) => A

  returns the contained Ok value or a provided default(if Err).

* unwrapOrElse :: (f: () => A) => A

  returns the contained Ok value or computes it from the function(if Err).

* map: \<A1>(f: (v: A) => A1)=> Result\<A1, B>

  maps a Result\<A, B> to Result\<A1, B> by applying a function to a contained Ok value, leaving an Err value untouched.

* mapErr :: \<B1>(f: (v: B) => B1) => Result\<A, B1>

  maps a Result\<A, B> to Result\<A, B1> by applying a function to a contained Err value, leaving an Ok value untouched.

* mapOr: \<A1>(f: (v: A) => A1, defaultValue: A1) => A1

  returns the provided default (if Err), or applies a function to the contained value (if Ok) and return it.

* mapOrElse: \<A1>(f: (v: A) => A1, defaultValue: () => A1) => A1

  maps a Result\<A, B> to A1 by applying fallback function default to a contained Err value,

  or function f to a contained Ok value.

* ap :: <A1, A2>(other: Result\<A1, B>) => Result\<A2, B>

  apply a Result<(a: A1) => A2, B> to a Result<A1, B>,

  note that the caller instance should be Result<(a: A) => A1, B>.

* bind :: \<A1>(f: (a: A) => Result\<A1, B>) =>Result\<A1, B>

  apply a function to the Ok value without concerning about Err.

  return Err if Err.

*  match :: \<T>(f: (v: A) => T, g: (v: B) => T) => T

  do something on Result<A, B>, note that you should handle the two cases: Ok\<A, B> and Err\<A, B>

  if return some value, the two handlers should return the same type.

  if you want to return different types, use do instead.

*  do :: \<T, U>(f: (v: A) => T, g: (v: B) => U) => T | U

  do something on Result<A, B>, note that you should handle the two cases: Ok\<A, B> and Err\<A, B>
