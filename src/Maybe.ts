import { err, ok, type Result } from './Result'

class Just<A> implements MaybeMethods<A> {
  #value: A
  constructor(value: A) {
    this.#value = value
  }

  static of<A>(value: A): Maybe<A> {
    return new Just(value)
  }

  expect(msg: string): A {
    return this.#value
  }

  map<B>(f: (v: A) => B): Maybe<B> {
    return just(f(this.#value))
  }
  mapOr<B>(f: (v: A) => B, defaultValue: B): B {
    return f(this.#value)
  }
  mapOrElse<B>(f: (v: A) => B, defaultValue: () => B): B {
    return f(this.#value)
  }
  unwrap(): A {
    return this.#value
  }
  unwrapOr(elseValue: A): A {
    return this.#value
  }
  unwrapOrElse(f: () => A): A {
    return this.#value
  }
  isJust(): this is Just<A> {
    return true
  }
  isNothing(): this is Nothing<A> {
    return false
  }
  ap<B, A>(other: Maybe<A>): Maybe<B> {
    return other.map(this.#value as (v: A) => B)
  }
  andThen<B>(f: (a: A) => Maybe<B>): Maybe<B> {
    return f(this.#value)
  }
  match<B>(onJust: (a: A) => B, onNothing: () => B): B {
    return onJust(this.#value)
  }
  do<T, U>(onJust: (a: A) => T, onNothing: () => U): T | U {
    return onJust(this.#value)
  }
  toResult<B>(err: B): Result<A, B> {
    return ok(this.#value)
  }
  private toJSON() {
    return {
      type: MaybeTag.Just,
      value: this.#value
    }
  }
  get [Symbol.toStringTag](): string {
    return MaybeTag.Just
  }

  [Symbol.iterator](): Iterator<A> {
    let done = false
    return {
      next: () => {
        if (done) {
          return { done: true, value: undefined }
        } else {
          done = true
          return { done: false, value: this.#value }
        }
      }
    }
  }
}

class Nothing<A> implements MaybeMethods<A> {
  static of<A>(): Maybe<A> {
    return new Nothing()
  }
  expect(msg: string): A {
    throw new Error(msg)
  }
  unwrap(): A {
    throw new TypeError('Call unwrap on Nothing!')
  }
  unwrapOr(elseValue: A): A {
    return elseValue
  }
  unwrapOrElse(f: () => A): A {
    return f()
  }
  isJust(): this is Just<A> {
    return false
  }
  isNothing(): this is Nothing<A> {
    return true
  }
  map<B>(f: (v: A) => B): Maybe<B> {
    return nothing()
  }
  mapOr<B>(f: (v: A) => B, defaultValue: B): B {
    return defaultValue
  }
  mapOrElse<B>(f: (v: A) => B, defaultValue: () => B): B {
    return defaultValue()
  }
  ap<B, A>(f: Maybe<A>): Maybe<B> {
    return nothing()
  }
  andThen<B>(f: (a: A) => Maybe<B>): Maybe<B> {
    return nothing()
  }
  match<B>(onJust: (a: A) => B, onNothing: () => B): B {
    return onNothing()
  }
  do<T, U>(onJust: (a: A) => T, onNothing: () => U): T | U {
    return onNothing()
  }
  toResult<B>(e: B): Result<A, B> {
    return err(e)
  }
  private toJSON() {
    return {
      type: MaybeTag.Nothing,
    }
  }
  get [Symbol.toStringTag](): string {
    return MaybeTag.Nothing
  }

  [Symbol.iterator](): Iterator<A> {
    let done = false
    return {
      next: () => {
        if (done) {
          return { done: true, value: undefined }
        } else {
          done = true
          return { done: true, value: undefined }
        }
      }
    }
  }
}

const enum MaybeTag {
  Just = 'Just',
  Nothing = 'Nothing',
}

export type MaybeObject<A> = { type: MaybeTag.Just, value: A } | { type: MaybeTag.Nothing }

export type Maybe<A> = Just<A> | Nothing<A>
/**
 * @description create a Just<A> from value
 * @param value the Maybe<A> value A
 * @returns Maybe<A>
 */
export const just = Just.of
/**
 * @description create a Nothing<A>
 * @returns Maybe<A>
 */
export const nothing = Nothing.of

/**
 * @description convert a string generated by stringify the Maybe<A> to a Maybe<A>
 */
export const fromString = <A>(s: string): Result<Maybe<A>, string> => {
  try {
    const obj = JSON.parse(s)
    if (
      !obj ||
      !obj.type ||
      obj.type !== MaybeTag.Just && obj.type !== MaybeTag.Nothing
    ) {
      throw new SyntaxError('Cannot parse to a Maybe!')
    }
    if (obj.type === MaybeTag.Just && obj.value !== null && obj.value !== undefined) {
      return ok(just(obj.value))
    }
    return ok(nothing())
  } catch (error) {
    return err((error as SyntaxError).message)
  }
}
/**
 * Creates a Maybe instance from a nullable value.
 * @param {A | null | undefined} value - The value to create the Maybe instance from.
 * @return {Maybe<A>} - The Maybe instance created from the value.
 */
export const fromNullable = <A>(value: A | null | undefined): Maybe<A> => {
  if (value === null || value === undefined) {
    return nothing()
  }
  return just(value)
}

export const isMaybe = <T>(a: unknown): a is Maybe<T> => a instanceof Just || a instanceof Nothing

export default {
  just,
  nothing,
  fromNullable,
  fromString,
  isMaybe
}
interface MaybeFunctor<A> {
  /**
   * @description convert Maybe<A> to Maybe<B> without unwrap the Maybe type which may caust an error
   */
  map: <B>(f: (v: A) => B) => Maybe<B>
}
interface MaybeApplicative<A> {
  /**
   * @description apply a Maybe<(a: A) => B> to a Maybe<A>,
   * note that the caller instance should be Maybe<(a: A) => B>.
   */
  ap: <B>(other: Maybe<A>) => Maybe<B>
}
interface MaybeMonad<A> {
  /**
   * @description apply a function to the Maybe value without concerning about Nothing.
   * return Nothing if Nothing.
   */
  andThen: <B>(f: (a: A) => Maybe<B>) => Maybe<B>
}

interface MaybeMethods<A> extends MaybeFunctor<A>, MaybeApplicative<A>, MaybeMonad<A> {
  isJust: () => boolean
  isNothing: () => boolean
  /**
   * Returns the contained `Just` value. Panics if the value is a `Nothing` with a custom panic message provided by msg.
   */
  expect: (msg: string) => A
  /**
   * @description returns the contained Maybe value, would panic on Nothing.
   */
  unwrap: () => A
  /**
   * @description returns the contained Maybe value or a provided default value(if Nothing).
   */
  unwrapOr: (defaultValue: A) => A
  /**
   * @description returns the contained Maybe value or return the parameter function's return value(if Nothing).
   */
  unwrapOrElse: (f: () => A) => A
  /**
   * @description returns the provided default result (if Nothing),
   * or applies the function to the contained value (if Just).
   */
  mapOr: <B>(f: (v: A) => B, defaultValue: B) => B
  /**
   * @description computes a default function result (if Nothing),
   * or applies a different function to the contained value (if Just).
   */
  mapOrElse: <B>(f: (v: A) => B, defaultValue: () => B) => B
  /**
   * @description transforms the Maybe<A> into a Result<A, B>, mapping Just<A> to Ok<A> and Nothing to Err<B>.
   */
  toResult: <B>(err: B) => Result<A, B>
  /**
   * @description do something on Maybe<A>, note that you should handle the two cases: Just<A> and Nothing
   * if return some value, the two handlers should return the same type.
   */
  match: <B>(onJust: (a: A) => B, onNothing: () => B) => B
  /**
   * @description do something on Maybe<A>, note that you should handle the two cases: Just<A> and Nothing
   */
  do: <T, U>(onJust: (a: A) => T, onNothing: () => U) => T | U
}
